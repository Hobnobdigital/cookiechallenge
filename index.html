<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cookie Challenge</title>
    <style>
        html, body { margin:0; height:100%; background:#111; color:#fff; font-family:sans-serif; overflow:hidden; }
        #outer { display:flex; flex-direction:column; height:100%; }
        #ui { font-size:20px; text-align:center; margin:6px 0; }
        #canvasWrap { flex:1; display:flex; justify-content:center; align-items:center; }
        #gameCanvas { background:#000; border:4px solid #fff; touch-action:none; max-width:98vw; max-height:65vh; }

        /* ---------- title screen ---------- */
        #titleScreen {
            position: fixed; inset: 0;
            /* FIXED: Changed background-size to 'contain' to prevent cropping the image */
            background: url('title.png') center/contain no-repeat;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        /* REMOVED: Black overlay as requested */
        #titleContent { position:relative; z-index:1; text-align:center; }
        #titleContent h1 { font-size:9vw; margin:0 0 15px; text-shadow:0 0 15px #000, 0 0 5px #000; }
        #titleContent button { padding:10px 24px; font-size:5vw; border:none; border-radius:6px; background:#d69c4e; color:#111; cursor: pointer; }

        #muteBtn { position:fixed; top:10px; right:10px; z-index:10; font-size:18px; padding:6px 10px; border:none; border-radius:4px; background:#d69c4e; color:#111; cursor: pointer; }

        /* ---------- on-screen D-pad ---------- */
        #controls { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); z-index:9; width:210px; height:170px; }
        .btn { position:absolute; width:68px; height:68px; border-radius:50%; background:rgba(255,255,255,.25); border:2px solid #fff; display:flex; justify-content:center; align-items:center; user-select:none; transition:.05s; }
        .btn:active { background:#fff; color:#000; transform:scale(.94); }
        #up { top:0; left:71px; }
        #down { bottom:0; left:71px; }
        #left { left:0; top:50%; transform:translateY(-50%); }
        #right { right:0; top:50%; transform:translateY(-50%); }
        .btn span { font-size:30px; pointer-events:none; }
        @media(pointer:fine) { #controls { display:none; } }
    </style>
</head>
<body>
    <div id="outer">
        <p id="ui" style="display:none">Score: 0</p>
        <div id="canvasWrap"><canvas id="gameCanvas"></canvas></div>
    </div>

    <div id="titleScreen">
        <div id="titleContent">
            <h1>Cookie&nbsp;Challenge</h1>
            <button id="startBtn">Start&nbsp;Game</button>
        </div>
    </div>

    <div id="controls">
        <div id="up"    class="btn"><span>â–²</span></div>
        <div id="down"  class="btn"><span>â–¼</span></div>
        <div id="left"  class="btn"><span>â—€</span></div>
        <div id="right" class="btn"><span>â–¶</span></div>
    </div>

    <button id="muteBtn">ðŸ”Š</button>
    <audio id="bgm" loop></audio>

<script>
/* ===== Configurable constants ===== */
const PS = 4, BASE_MS = 2, BASE_CR = 6, BASE_MR = 12, PR = 10;
// FIXED: Added missing constants for power-up and bullet radii
const BOOST_R = 12, BULLET_R = 4;
const STAR_TIME = 5000, BLASTER_TIME = 10000;
const MONSTER_SHOOT_LEVEL = 4, MON_SHOOT_COOLDOWN = 4000;

/* ===== MP3 playlist ===== */
let playlist = [
    // FIXED: Removed extra single quotes from first song filename
    "Baby (Is it a Crime)' - Rema (Lyric video).mp3",
    "Backstreet Boys - Everybody (Backstreet's Back) (Lyrics).mp3",
    "Billie Eilish - BIRDS OF A FEATHER (Official Lyric Video).mp3",
    "Dave & Central Cee - Sprinter (Clean).mp3",
    "Davido - If (lyrics).mp3",
    "How You Remind Me - Nickelback (Clean Version).mp3",
    "Kris Kross - Jump (Radio Edit) [Audio HQ].mp3",
    "TLC - Waterfalls (Lyrics).mp3",
    "Sabrina Carpenter - Espresso.mp3",
    "Tubthumping (I Get Knocked Down) Lyrics.mp3"
];

/* ===== DOM ===== */
const cvs = document.getElementById('gameCanvas'), ctx = cvs.getContext('2d'),
      ui = document.getElementById('ui'), title = document.getElementById('titleScreen'),
      startBtn = document.getElementById('startBtn'), mute = document.getElementById('muteBtn'),
      bgm = document.getElementById('bgm');
const mobile = matchMedia('(pointer:coarse)').matches;

function fit() {
    const w = innerWidth - 24, h = (innerHeight - (mobile ? 220 : 60)) - 24;
    cvs.width = w;
    cvs.height = h;
}
addEventListener('resize', fit);
fit();

/* ===== D-pad ===== */
const dirs = { up: 0, down: 0, left: 0, right: 0 };
['up', 'down', 'left', 'right'].forEach(id => {
    ['touchstart', 'mousedown'].forEach(ev => sel(id).addEventListener(ev, e => { e.preventDefault(); dirs[id] = 1; }));
    ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(ev => sel(id).addEventListener(ev, e => { e.preventDefault(); dirs[id] = 0; }));
});
function sel(id) { return document.getElementById(id) }

/* ===== Web-Audio Helpers ===== */
const AC = window.AudioContext || window.webkitAudioContext, ac = new AC();
const beep = (f, d=120, t='square', v=.4) => { const o = ac.createOscillator(), g = ac.createGain(); o.type = t; o.frequency.value = f; g.gain.value = v; o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime + d / 1e3); };
const eatSfx = () => [932, 1175, 1397].forEach((f, i) => setTimeout(() => beep(f, 90, 'square', .35), i * 25));
const levelSfx = () => [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => beep(f, 140, 'triangle', .4), i * 140));
const boomSfx = () => [330, 196, 98].forEach((f, i) => setTimeout(() => beep(f, 180, 'sawtooth', .5), i * 70));
const hitSfx = () => beep(110, 340, 'square', .5);
const fireSfx = () => beep(1568, 60, 'square', .45);
// FIXED: Added missing powerSfx function
const powerSfx = () => [659, 784, 1046].forEach((f, i) => setTimeout(() => beep(f, 100, 'sine', .4), i * 50));

/* ===== Game State ===== */
// FIXED: Consolidated all game state variables here. Removed redeclarations elsewhere.
let p, cookies, mons, playerBullets, monsterBullets, score, level, starTimer, blasterTimer,
    powerSpark, gameOver, run, monSpeed, monsterShootCd, star, blaster;

/* ----- helpers ----- */
const R = () => ({ x: 20 + Math.random() * (cvs.width - 40), y: 20 + Math.random() * (cvs.height - 40) });
const D = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

/* ===== Playlist ===== */
let songs = [...playlist];
function nextSong() {
    if (!songs.length) songs = [...playlist];
    const idx = Math.floor(Math.random() * songs.length);
    const s = songs.splice(idx, 1)[0];
    bgm.src = encodeURI(s);
    bgm.play().catch(() => {}); // ignore autoplay promise
}

/* ===== Reset ===== */
function reset() {
    p = { x: cvs.width / 2, y: cvs.height / 2, dx: 0, dy: 0, color: '#4ec5f1' };
    cookies = []; mons = []; playerBullets = []; monsterBullets = [];
    score = 0; level = 1; monSpeed = BASE_MS; monsterShootCd = MON_SHOOT_COOLDOWN;
    starTimer = 0; blasterTimer = 0; powerSpark = 0; gameOver = 0;
    star = null; blaster = null; // Initialize power-ups
    spawnCookies();
    spawnMonsters(5);
    ui.textContent = 'Score: 0';
    nextSong();
    levelSfx();
}

/* ===== Spawners ===== */
function spawnCookies() { for (let i = 0; i < 20; i++) cookies.push(R()); }
function spawnMonsters(n) {
    for (let i = 0; i < n; i++) {
        let m = R();
        let a = Math.random() * 6.28;
        m.dx = Math.cos(a) * monSpeed;
        m.dy = Math.sin(a) * monSpeed;
        m.r = BASE_MR + (level * 2);
        m.cool = monsterShootCd * (.7 + .3 * Math.random());
        m.tCool = m.cool;
        mons.push(m);
    }
}
/* power-ups */
let powerList = []; // each level choose 1-2
function choosePowerups() {
    powerList = ['star', 'blaster'];
    if (Math.random() < 0.4) powerList.pop(); // 60% chance to keep both, else only one
}

/* ===== Controls ===== */
function moveDir() {
    p.dx = (dirs.left ? -PS : 0) + (dirs.right ? PS : 0);
    p.dy = (dirs.up ? -PS : 0) + (dirs.down ? PS : 0);
}

function firePlayer() {
    if (blasterTimer <= 0 || gameOver) return;
    fireSfx();
    playerBullets.push({ x: p.x, y: p.y, dx: 0, dy: -10 });
}

function fireMonster(m) {
    if (level < MONSTER_SHOOT_LEVEL) return;
    const ang = Math.atan2(p.y - m.y, p.x - m.x);
    monsterBullets.push({ x: m.x, y: m.y, dx: Math.cos(ang) * 4, dy: Math.sin(ang) * 4 });
}

/* ===== Update Loop ===== */
function update(dt) {
    if (!gameOver) {
        /* move player */
        moveDir();
        p.x = Math.max(PR, Math.min(cvs.width - PR, p.x + p.dx));
        p.y = Math.max(PR, Math.min(cvs.height - PR, p.y + p.dy));

        /* timers */
        if (starTimer > 0) { starTimer -= dt; powerSpark ^= 1; if (starTimer <= 0) p.color = '#4ec5f1'; }
        if (blasterTimer > 0) { blasterTimer -= dt; if (blasterTimer <= 0) p.color = '#4ec5f1'; }

        /* bullets */
        playerBullets.forEach(b => b.y += b.dy);
        monsterBullets.forEach(b => { b.x += b.dx; b.y += b.dy });
        playerBullets = playerBullets.filter(b => b.y > -20);
        monsterBullets = monsterBullets.filter(b => b.x > -20 && b.x < cvs.width + 20 && b.y > -20 && b.y < cvs.height + 20);

        /* monsters */
        mons.forEach(m => {
            m.x += m.dx; m.y += m.dy;
            if (m.x < m.r || m.x > cvs.width - m.r) m.dx *= -1;
            if (m.y < m.r || m.y > cvs.height - m.r) m.dy *= -1;
            m.tCool -= dt;
            if (m.tCool <= 0) { fireMonster(m); m.tCool = m.cool; }
        });

        /* eat cookies */
        cookies = cookies.filter(c => {
            if (D(c, p) < PR + BASE_CR) { score += 10; ui.textContent = 'Score: ' + score; eatSfx(); return false; }
            return true;
        });

        /* spawn power-ups once per level */
        if (!powerList.length && cookies.length <= 15) choosePowerups();
        if (powerList.includes('star') && !star && cookies.length <= 12) { star = R(); }
        if (powerList.includes('blaster') && !blaster && cookies.length <= 6) { blaster = R(); }

        /* power-up pick-ups */
        if (star && D(star, p) < PR + BOOST_R) {
            star = null; starTimer = STAR_TIME; p.color = '#ffd700'; powerSfx();
        }
        if (blaster && D(blaster, p) < PR + BOOST_R) {
            blaster = null; blasterTimer = BLASTER_TIME; p.color = '#00e0ff'; powerSfx();
        }

        /* bullet-monster collisions */
        playerBullets = playerBullets.filter(b => {
            const hitMonster = mons.find(m => D(b, m) < m.r + BULLET_R);
            if(hitMonster) {
                mons = mons.filter(m => m !== hitMonster);
                boomSfx();
                score += 50;
                ui.textContent = 'Score: ' + score;
                return false; // remove bullet
            }
            return true; // keep bullet
        });

        /* invincible stomp */
        if (starTimer > 0) {
            mons = mons.filter(m => {
                if (D(m, p) < m.r + PR) { boomSfx(); score += 30; ui.textContent = 'Score: ' + score; return false; }
                return true;
            });
        } else if (mons.some(m => D(m, p) < m.r + PR)) {
            gameOver = 1; hitSfx(); bgm.pause();
        }

        /* monster bullet hits player */
        // FIXED: Changed !starTimer>0 to clearer starTimer <= 0
        if (starTimer <= 0 && monsterBullets.some(b => D(b, p) < PR + BULLET_R)) {
            gameOver = 1; hitSfx(); bgm.pause();
        }

        /* next level */
        if (!cookies.length) {
            level++; monSpeed += .3; monsterShootCd = Math.max(1500, monsterShootCd * .9);
            powerList = []; star = null; blaster = null;
            spawnCookies(); spawnMonsters(3 + level * 2);
            nextSong(); levelSfx();
        }
    }
}

/* ===== Draw ===== */
// FIXED: Removed redeclaration of star and blaster. They are now in the main state block.
function circ(x, y, r, c) { ctx.fillStyle = c; ctx.beginPath(); ctx.arc(x, y, r, 0, 6.28); ctx.fill(); }
function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, cvs.width, cvs.height);

    cookies.forEach(c => { circ(c.x, c.y, BASE_CR, '#d69c4e'); circ(c.x - 2, c.y - 1, 2, '#925c27'); circ(c.x + 2, c.y + 1, 2, '#925c27'); });
    if (star) { circ(star.x, star.y, BOOST_R, '#ffd700'); }
    if (blaster) { circ(blaster.x, blaster.y, BOOST_R, '#00e0ff'); }

    playerBullets.forEach(b => circ(b.x, b.y, BULLET_R, '#d69c4e'));
    monsterBullets.forEach(b => circ(b.x, b.y, BULLET_R, '#3d2b1f'));

    if (starTimer > 0 && powerSpark) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, PR + 4, 0, 6.28); ctx.stroke(); }
    circ(p.x, p.y, PR, p.color);

    mons.forEach(m => {
        const col = level < 2 ? '#e63946' : level < 4 ? '#8b5cf6' : '#22c55e';
        circ(m.x, m.y, m.r, col);
        circ(m.x - m.r / 3, m.y - m.r / 3, m.r / 3, '#fff');
        circ(m.x + m.r / 3, m.y - m.r / 3, m.r / 3, '#fff');
        circ(m.x - m.r / 3, m.y - m.r / 3, m.r / 6, '#000');
        circ(m.x + m.r / 3, m.y - m.r / 3, m.r / 6, '#000');
    });

    if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,.75)'; ctx.fillRect(0, 0, cvs.width, cvs.height);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = '8vw sans-serif';
        ctx.fillText('Game Over', cvs.width / 2, cvs.height / 2 - 20);
        ctx.font = '4vw sans-serif'; ctx.fillText('Press R or tap screen', cvs.width / 2, cvs.height / 2 + 30);
    }
}

/* ===== Main Loop ===== */
let last = 0;
function loop(t) {
    const dt = t - last;
    last = t;
    update(dt);
    draw();
    if (run) requestAnimationFrame(loop);
}

function startGame() {
    if(run && !gameOver) return; // Prevent restarting mid-game
    title.style.display = 'none';
    ui.style.display = 'block';
    fit();
    reset();
    run = 1;
    ac.resume();
    last = performance.now();
    loop(last);
}

startBtn.addEventListener('click', startGame);
addEventListener('keydown', e => {
    // FIXED: Allow any key to start the game only if it's not already running
    if (!run) { startGame(); return; }
    if (gameOver && e.key === 'r') { startGame(); return; }
    if (e.key === ' ') { firePlayer(); }
    if (e.key === 'ArrowUp' || e.key === 'w') dirs.up = 1;
    if (e.key === 'ArrowDown' || e.key === 's') dirs.down = 1;
    if (e.key === 'ArrowLeft' || e.key === 'a') dirs.left = 1;
    if (e.key === 'ArrowRight' || e.key === 'd') dirs.right = 1;
});
addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') dirs.up = 0;
    if (e.key === 'ArrowDown' || e.key === 's') dirs.down = 0;
    if (e.key === 'ArrowLeft' || e.key === 'a') dirs.left = 0;
    if (e.key === 'ArrowRight' || e.key === 'd') dirs.right = 0;
});

// IMPROVEMENT: Added click listener to restart on game over screen
cvs.addEventListener('click', () => {
    if (gameOver) {
        startGame();
    } else if (blasterTimer > 0) {
        firePlayer();
    }
});
cvs.addEventListener('touchstart', e => { if (mobile) firePlayer(); });
mute.onclick = () => { bgm.muted = !bgm.muted; mute.textContent = bgm.muted ? 'ðŸ”‡' : 'ðŸ”Š'; };
</script>
</body>
</html>
