<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cookie Challenge</title>
    <style>
        html, body { margin:0; height:100%; background:#111; color:#fff; font-family:sans-serif; overflow:hidden; }
        #outer { display:flex; flex-direction:column; height:100%; }
        #ui { font-size:20px; text-align:center; margin:6px 0; }
        #canvasWrap { flex:1; display:flex; justify-content:center; align-items:center; }
        #gameCanvas { background:#000; border:4px solid #fff; touch-action:none; max-width:98vw; max-height:65vh; }

        /* ---------- title screen ---------- */
        #titleScreen {
            position: fixed; inset: 0;
            background: url('title.png') center/contain no-repeat;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #titleContent { position:relative; z-index:1; text-align:center; }
        #titleContent h1 { font-size:9vw; margin:0 0 15px; text-shadow:0 0 15px #000, 0 0 5px #000; }
        #titleContent button { padding:10px 24px; font-size:5vw; border:none; border-radius:6px; background:#d69c4e; color:#111; cursor: pointer; }

        #muteBtn { position:fixed; top:10px; right:10px; z-index:10; font-size:18px; padding:6px 10px; border:none; border-radius:4px; background:#d69c4e; color:#111; cursor: pointer; }

        /* ---------- on-screen D-pad ---------- */
        #controls { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); z-index:9; width:210px; height:170px; }
        .btn { position:absolute; width:68px; height:68px; border-radius:50%; background:rgba(255,255,255,.25); border:2px solid #fff; display:flex; justify-content:center; align-items:center; user-select:none; transition:.05s; }
        .btn:active { background:#fff; color:#000; transform:scale(.94); }
        #up { top:0; left:71px; }
        #down { bottom:0; left:71px; }
        #left { left:0; top:50%; transform:translateY(-50%); }
        #right { right:0; top:50%; transform:translateY(-50%); }
        .btn span { font-size:30px; pointer-events:none; }
        @media(pointer:fine) { #controls { display:none; } }
    </style>
</head>
<body>
    <div id="outer">
        <p id="ui" style="display:none">Score: 0</p>
        <div id="canvasWrap"><canvas id="gameCanvas"></canvas></div>
    </div>

    <!-- title -->
    <div id="titleScreen">
        <div id="titleContent">
            <h1>Cookie&nbsp;Challenge</h1>
            <button id="startBtn">Start&nbsp;Game</button>
        </div>
    </div>

    <!-- D-pad -->
    <div id="controls">
        <div id="up"    class="btn"><span>â–²</span></div>
        <div id="down"  class="btn"><span>â–¼</span></div>
        <div id="left"  class="btn"><span>â—€</span></div>
        <div id="right" class="btn"><span>â–¶</span></div>
    </div>

    <button id="muteBtn">ðŸ”Š</button>
    <audio id="bgm" loop></audio>

<script>
/* ===== Configurable constants ===== */
const PS = 4, PS_BOOST = 7;
const BASE_MS = 2, BASE_CR = 6, BASE_MR = 12, PR = 10;
const BOOST_R = 12, PLAYER_BULLET_R = 4, MONSTER_BULLET_R = 8;
const STAR_TIME = 8000, BLASTER_TIME = 10000;
const MONSTER_SHOOT_LEVEL = 4, MON_SHOOT_COOLDOWN = 5500;
const AUTO_FIRE_RATE = 150;
const MAX_POWERUPS_PER_LEVEL = 3; // NEW: Max power-ups per level

/* ===== MP3 playlist ===== */
let playlist = [
    "Baby (Is it a Crime)' - Rema (Lyric video).mp3",
    "Backstreet Boys - Everybody (Backstreet's Back) (Lyrics).mp3",
    "Billie Eilish - BIRDS OF A FEATHER (Official Lyric Video).mp3",
    "Dave & Central Cee - Sprinter (Clean).mp3",
    "Davido - If (lyrics).mp3",
    "How You Remind Me - Nickelback (Clean Version).mp3",
    "Kris Kross - Jump (Radio Edit) [Audio HQ].mp3",
    "TLC - Waterfalls (Lyrics).mp3",
    "Sabrina Carpenter - Espresso.mp3",
    "Tubthumping (I Get Knocked Down) Lyrics.mp3"
];

/* ===== DOM ===== */
const cvs = document.getElementById('gameCanvas'), ctx = cvs.getContext('2d'),
      ui = document.getElementById('ui'), title = document.getElementById('titleScreen'),
      startBtn = document.getElementById('startBtn'), mute = document.getElementById('muteBtn'),
      bgm = document.getElementById('bgm');
const mobile = matchMedia('(pointer:coarse)').matches;

function fit() {
    const w = innerWidth - 24, h = (innerHeight - (mobile ? 220 : 60)) - 24;
    cvs.width = w;
    cvs.height = h;
}
addEventListener('resize', fit);
fit();

/* ===== D-pad ===== */
const dirs = { up: 0, down: 0, left: 0, right: 0 };
['up', 'down', 'left', 'right'].forEach(id => {
    ['touchstart', 'mousedown'].forEach(ev => sel(id).addEventListener(ev, e => { e.preventDefault(); dirs[id] = 1; }));
    ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(ev => sel(id).addEventListener(ev, e => { e.preventDefault(); dirs[id] = 0; }));
});
function sel(id) { return document.getElementById(id) }

/* ===== Web-Audio Helpers ===== */
const AC = window.AudioContext || window.webkitAudioContext, ac = new AC();
const beep = (f, d=120, t='square', v=.4) => { const o = ac.createOscillator(), g = ac.createGain(); o.type = t; o.frequency.value = f; g.gain.value = v; o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime + d / 1e3); };
const eatSfx = () => [932, 1175, 1397].forEach((f, i) => setTimeout(() => beep(f, 90, 'square', .35), i * 25));
const levelSfx = () => [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => beep(f, 140, 'triangle', .4), i * 140));
const hitSfx = () => beep(110, 340, 'square', .5);
const fireSfx = () => beep(1568, 60, 'square', .2);
const powerSfx = () => [659, 784, 1046].forEach((f, i) => setTimeout(() => beep(f, 100, 'sine', .4), i * 50));
const stompSfx = () => [220, 147, 98, 73].forEach((f, i) => setTimeout(() => beep(f, 200, 'sawtooth', .5), i * 40));

/* ===== Game State ===== */
let p, cookies, mons, playerBullets, monsterBullets, particles, score, level, starTimer, blasterTimer,
    powerSpark, gameOver, run, monSpeed, monsterShootCd, star, blaster, autoFireCooldown,
    powerupsSpawnedThisLevel; // NEW: Counter for spawned power-ups

/* ----- helpers ----- */
const R = () => ({ x: 20 + Math.random() * (cvs.width - 40), y: 20 + Math.random() * (cvs.height - 40) });
const D = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

/* ===== Playlist ===== */
let songs = [...playlist];
function nextSong() {
    if (!songs.length) songs = [...playlist];
    const idx = Math.floor(Math.random() * songs.length);
    const s = songs.splice(idx, 1)[0];
    bgm.src = encodeURI(s);
    bgm.play().catch(() => {});
}

/* ===== Reset ===== */
function reset() {
    p = { x: cvs.width / 2, y: cvs.height / 2, dx: 0, dy: 0, color: '#4ec5f1' };
    cookies = []; mons = []; playerBullets = []; monsterBullets = []; particles = [];
    score = 0; level = 1; monSpeed = BASE_MS; monsterShootCd = MON_SHOOT_COOLDOWN;
    starTimer = 0; blasterTimer = 0; powerSpark = 0; gameOver = 0;
    star = null; blaster = null; autoFireCooldown = 0;
    powerupsSpawnedThisLevel = 0; // REVISED: Initialize counter
    spawnCookies();
    spawnMonsters(5);
    ui.textContent = 'Score: 0';
    nextSong();
    levelSfx();
}

/* ===== Spawners ===== */
function spawnCookies() { for (let i = 0; i < 20; i++) cookies.push(R()); }
function spawnMonsters(n) {
    for (let i = 0; i < n; i++) {
        let m = R();
        let a = Math.random() * 6.28;
        m.dx = Math.cos(a) * monSpeed;
        m.dy = Math.sin(a) * monSpeed;
        m.r = BASE_MR + (level * 2);
        m.cool = monsterShootCd * (.7 + .3 * Math.random());
        m.tCool = m.cool;
        mons.push(m);
    }
}
let powerList = [];
function choosePowerups() {
    powerList = ['star', 'blaster'];
    if (Math.random() < 0.4) powerList.pop();
}

function createDisintegration(monster) {
    for (let i = 0; i < 20; i++) {
        const angle = Math.random() * 6.28;
        const speed = 2 + Math.random() * 4;
        particles.push({
            x: monster.x, y: monster.y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            life: 100,
            color: monster.color
        });
    }
}

/* ===== Controls ===== */
function moveDir() {
    const currentSpeed = starTimer > 0 ? PS_BOOST : PS;
    p.dx = (dirs.left ? -currentSpeed : 0) + (dirs.right ? currentSpeed : 0);
    p.dy = (dirs.up ? -currentSpeed : 0) + (dirs.down ? currentSpeed : 0);
}

function fireCookie() {
    if (gameOver) return;
    fireSfx();
    playerBullets.push({ x: p.x, y: p.y, dx: 0, dy: -10 });
}

function fireMonster(m) {
    if (level < MONSTER_SHOOT_LEVEL) return;
    const ang = Math.atan2(p.y - m.y, p.x - m.x);
    monsterBullets.push({ x: m.x, y: m.y, dx: Math.cos(ang) * 4, dy: Math.sin(ang) * 4 });
}

/* ===== Update Loop ===== */
function update(dt) {
    if (!gameOver) {
        moveDir();
        p.x = Math.max(PR, Math.min(cvs.width - PR, p.x + p.dx));
        p.y = Math.max(PR, Math.min(cvs.height - PR, p.y + p.dy));

        if (starTimer > 0) { starTimer -= dt; powerSpark ^= 1; if (starTimer <= 0) p.color = '#4ec5f1'; }
        if (blasterTimer > 0) { blasterTimer -= dt; if (blasterTimer <= 0) p.color = '#4ec5f1'; }

        if (blasterTimer > 0) {
            if (autoFireCooldown > 0) { autoFireCooldown -= dt; }
            else { fireCookie(); autoFireCooldown = AUTO_FIRE_RATE; }
        }

        playerBullets.forEach(b => b.y += b.dy);
        monsterBullets.forEach(b => { b.x += b.dx; b.y += b.dy });
        playerBullets = playerBullets.filter(b => b.y > -20);
        monsterBullets = monsterBullets.filter(b => b.x > -20 && b.x < cvs.width + 20 && b.y > -20 && b.y < cvs.height + 20);

        particles.forEach(p => { p.x += p.dx; p.y += p.dy; p.life -= 2; p.dx *= 0.98; p.dy *= 0.98; });
        particles = particles.filter(p => p.life > 0);

        mons.forEach(m => {
            m.x += m.dx; m.y += m.dy;
            if (m.x < m.r || m.x > cvs.width - m.r) m.dx *= -1;
            if (m.y < m.r || m.y > cvs.height - m.r) m.dy *= -1;
            m.tCool -= dt;
            if (m.tCool <= 0) { fireMonster(m); m.tCool = m.cool; }
        });

        cookies = cookies.filter(c => {
            if (D(c, p) < PR + BASE_CR) { score += 10; ui.textContent = 'Score: ' + score; eatSfx(); return false; }
            return true;
        });

        /* REVISED: Spawn power-ups with a limit per level */
        if (!powerList.length && cookies.length <= 15) choosePowerups();
        if (powerupsSpawnedThisLevel < MAX_POWERUPS_PER_LEVEL) {
            if (powerList.includes('star') && !star && cookies.length <= 12) {
                star = R();
                powerupsSpawnedThisLevel++;
            }
            if (powerList.includes('blaster') && !blaster && cookies.length <= 6) {
                blaster = R();
                powerupsSpawnedThisLevel++;
            }
        }

        if (star && D(star, p) < PR + BOOST_R) {
            star = null; starTimer = STAR_TIME; p.color = '#ffd700'; powerSfx();
        }
        if (blaster && D(blaster, p) < PR + BOOST_R) {
            blaster = null; blasterTimer = BLASTER_TIME; p.color = '#00e0ff'; powerSfx();
        }

        playerBullets = playerBullets.filter(b => {
            const hitMonster = mons.find(m => D(b, m) < m.r + PLAYER_BULLET_R);
            if(hitMonster) {
                mons = mons.filter(m => m !== hitMonster);
                createDisintegration(hitMonster);
                stompSfx();
                score += 50;
                ui.textContent = 'Score: ' + score;
                return false;
            }
            return true;
        });

        if (starTimer > 0) {
            mons = mons.filter(m => {
                if (D(m, p) < m.r + PR) {
                    stompSfx();
                    createDisintegration(m);
                    score += 30;
                    ui.textContent = 'Score: ' + score;
                    return false;
                }
                return true;
            });
        } else if (mons.some(m => D(m, p) < m.r + PR)) {
            gameOver = 1; hitSfx(); bgm.pause();
        }

        if (starTimer <= 0 && monsterBullets.some(b => D(b, p) < PR + MONSTER_BULLET_R)) {
            gameOver = 1; hitSfx(); bgm.pause();
        }

        if (!cookies.length) {
            level++;
            monsterShootCd = Math.max(1500, monsterShootCd * .9);
            powerList = []; star = null; blaster = null;
            powerupsSpawnedThisLevel = 0; // REVISED: Reset counter for new level
            spawnCookies();
            spawnMonsters(4 + level);
            nextSong(); levelSfx();
        }
    }
}

/* ===== Draw ===== */
function circ(x, y, r, c) { ctx.fillStyle = c; ctx.beginPath(); ctx.arc(x, y, r, 0, 6.28); ctx.fill(); }
function drawCookie(x, y, r) {
    circ(x, y, r, '#d69c4e');
    circ(x - r*0.3, y - r*0.2, r*0.3, '#925c27');
    circ(x + r*0.3, y + r*0.2, r*0.3, '#925c27');
}
// REVISED: Function to draw a better-looking star
function drawStar(x, y, radius, blink) {
    if (blink && powerSpark) return;

    const spikes = 5;
    const outerRadius = radius;
    const innerRadius = radius / 2;
    let rot = Math.PI / 2 * 3;
    let step = Math.PI / spikes;

    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.moveTo(x, y - outerRadius);
    for (let i = 0; i < spikes; i++) {
        ctx.lineTo(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
        rot += step;
        ctx.lineTo(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
        rot += step;
    }
    ctx.lineTo(x, y - outerRadius);
    ctx.closePath();
    ctx.fill();
}
// REVISED: Function to draw a better-looking gun
function drawGun(x, y, size) {
    const barrelWidth = size * 1.8;
    const barrelHeight = size * 0.5;
    const handleWidth = size * 0.6;
    const handleHeight = size * 0.8;

    ctx.fillStyle = '#00e0ff';
    // Main barrel, pointing right
    ctx.fillRect(x - barrelWidth/2, y - barrelHeight/2, barrelWidth, barrelHeight);
    // Handle, positioned towards the back
    ctx.fillRect(x - barrelWidth/2 + handleWidth * 0.5, y, handleWidth, handleHeight);
}

function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, cvs.width, cvs.height);

    cookies.forEach(c => drawCookie(c.x, c.y, BASE_CR));
    if (star) { drawStar(star.x, star.y, BOOST_R, true); }
    if (blaster) { drawGun(blaster.x, blaster.y, BOOST_R * 1.5); }

    playerBullets.forEach(b => drawCookie(b.x, b.y, PLAYER_BULLET_R));
    monsterBullets.forEach(b => circ(b.x, b.y, MONSTER_BULLET_R, '#e63946'));
    
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 100;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
    ctx.globalAlpha = 1;

    if (starTimer > 0 && powerSpark) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, PR + 4, 0, 6.28); ctx.stroke(); }
    circ(p.x, p.y, PR, p.color);

    mons.forEach(m => {
        const col = level < 2 ? '#e63946' : level < 4 ? '#8b5cf6' : '#22c55e';
        m.color = col;
        circ(m.x, m.y, m.r, col);
        circ(m.x - m.r / 3, m.y - m.r / 3, m.r / 3, '#fff');
        circ(m.x + m.r / 3, m.y - m.r / 3, m.r / 3, '#fff');
        circ(m.x - m.r / 3, m.y - m.r / 3, m.r / 6, '#000');
        circ(m.x + m.r / 3, m.y - m.r / 3, m.r / 6, '#000');
    });

    if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,.75)'; ctx.fillRect(0, 0, cvs.width, cvs.height);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = '8vw sans-serif';
        ctx.fillText('Game Over', cvs.width / 2, cvs.height / 2 - 20);
        ctx.font = '4vw sans-serif'; ctx.fillText('Press R or tap screen', cvs.width / 2, cvs.height / 2 + 30);
    }
}

/* ===== Main Loop ===== */
let last = 0;
function loop(t) {
    const dt = t - last;
    last = t;
    update(dt);
    draw();
    if (run) requestAnimationFrame(loop);
}

function startGame() {
    if(run && !gameOver) return;
    title.style.display = 'none';
    ui.style.display = 'block';
    fit();
    reset();
    run = 1;
    ac.resume();
    last = performance.now();
    loop(last);
}

startBtn.addEventListener('click', startGame);
addEventListener('keydown', e => {
    if (!run) { startGame(); return; }
    if (gameOver && e.key === 'r') { startGame(); return; }
    if (e.key === ' ' && blasterTimer <= 0) { fireCookie(); }
    if (e.key === 'ArrowUp' || e.key === 'w') dirs.up = 1;
    if (e.key === 'ArrowDown' || e.key === 's') dirs.down = 1;
    if (e.key === 'ArrowLeft' || e.key === 'a') dirs.left = 1;
    if (e.key === 'ArrowRight' || e.key === 'd') dirs.right = 1;
});
addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') dirs.up = 0;
    if (e.key === 'ArrowDown' || e.key === 's') dirs.down = 0;
    if (e.key === 'ArrowLeft' || e.key === 'a') dirs.left = 0;
    if (e.key === 'ArrowRight' || e.key === 'd') dirs.right = 0;
});

cvs.addEventListener('click', () => {
    if (gameOver) {
        startGame();
    } else if (blasterTimer <= 0) {
        fireCookie();
    }
});
cvs.addEventListener('touchstart', e => { if (mobile && blasterTimer <= 0) fireCookie(); });
mute.onclick = () => { bgm.muted = !bgm.muted; mute.textContent = bgm.muted ? 'ðŸ”‡' : 'ðŸ”Š'; };
</script>
</body>
</html>
